STACK7 NOTES:
*objdump -d -M intel stack7
*<Main> does basic setup and then immediately calls <getpath>
*<getpath> can be broken down into a few signifigant sections:
<-------------------------------------------------------------------------------------------------------------------------------------------------------------------->
	080484c4 <getpath>:
	1.) PROLOG ;get it started, get it started, HOT!
	 80484c4:       55                      push   ebp						;prolog
	 80484c5:       89 e5                   mov    ebp,esp					;prolog
	 80484c7:       83 ec 68                sub    esp,0x68					;104bytes of stackframe

	2.) 1ST PRINTF ;print to user, presumably asking for input - needs confirmed
	 80484ca:       b8 20 86 04 08          mov    eax,0x8048620			;argument setup for printf call
	 80484cf:       89 04 24                mov    DWORD PTR [esp],eax		;setup
	 80484d2:       e8 0d ff ff ff          call   80483e4 <printf@plt>		;call to printf

	3.) FFLUSH ;clean the user space buffer before it get's used
	 80484d7:       a1 80 97 04 08          mov    eax,ds:0x8049780			;data segement value at address loaded into eax
	 80484dc:       89 04 24                mov    DWORD PTR [esp],eax		;setup
	 80484df:       e8 f0 fe ff ff          call   80483d4 <fflush@plt>		;call to fflush

	4.) GETS ;get user input
	 80484e4:       8d 45 b4                lea    eax,[ebp-0x4c]			;take value at ebp-76 and store it in eax
	 80484e7:       89 04 24                mov    DWORD PTR [esp],eax		;store the value in eax to the location of esp(top of stack frame)
	 80484ea:       e8 b5 fe ff ff          call   80483a4 <gets@plt>		;call to gets
	 
	5.)CHECK RETURN VALUE ;check the current return value to make sure we are not jumping into, presumably, libc - needs confirmed
	 80484ef:       8b 45 04                mov    eax,DWORD PTR [ebp+0x4]	;move value at ebp+4 and store in eax, getting the return value of the stackframe
	 80484f2:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax	;placing the value in eax into ebp-12
	 80484f5:       8b 45 f4                mov    eax,DWORD PTR [ebp-0xc]	;move value at ebp-12 into eax
	 80484f8:       25 00 00 00 b0          and    eax,0xb0000000			;setup for compare, checking against value 0xb0000000
	 80484fd:       3d 00 00 00 b0          cmp    eax,0xb0000000			;compare before jump
	 8048502:       75 20                   jne    8048524 <getpath+0x60>	;this compare is making sure that the return address is not overwritten
	 
	6.) PRINTF IF NO JUMP ;if we don't overwrite the return address with an invalid address, continue program execution by jumping over error
	 8048504:       b8 34 86 04 08          mov    eax,0x8048634			;setup for printf
	 8048509:       8b 55 f4                mov    edx,DWORD PTR [ebp-0xc]	;move value at ebp-12 into edx
	 804850c:       89 54 24 04             mov    DWORD PTR [esp+0x4],edx	;move value at edx into esp+4
	 8048510:       89 04 24                mov    DWORD PTR [esp],eax		;move eax into the location of esp(top of the stack frame)
	 8048513:       e8 cc fe ff ff          call   80483e4 <printf@plt>		;call to printf

	7.) EXIT WITH ERROR ;if we muck it up, exit with error
	 8048518:       c7 04 24 01 00 00 00    mov    DWORD PTR [esp],0x1		;setup for exit with status of 1
	 804851f:       e8 a0 fe ff ff          call   80483c4 <_exit@plt>		;call to exit

	8.) PRINTF AFTER JUMP ;presumably write out some sort of sucess message if the user passed input doesn't crash program or trigger error check
	 8048524:       b8 40 86 04 08          mov    eax,0x8048640			;setup for printf
	 8048529:       8d 55 b4                lea    edx,[ebp-0x4c]			;take value stored at ebp-76 and move it into edx
	 804852c:       89 54 24 04             mov    DWORD PTR [esp+0x4],edx	;take value in edx and store it in esp+4
	 8048530:       89 04 24                mov    DWORD PTR [esp],eax		;take eax and place it at esp
	 8048533:       e8 ac fe ff ff          call   80483e4 <printf@plt>		;call to printf
	 
	9.) STRDUP ;duplicates a string - no freaking clue why this is here, must be referrenced by another function?
	 8048538:       8d 45 b4                lea    eax,[ebp-0x4c]			;load the address at ebp-76 into eax
	 804853b:       89 04 24                mov    DWORD PTR [esp],eax		;take the addres from eax and store it at esp(top of stack frame)
	 804853e:       e8 b1 fe ff ff          call   80483f4 <strdup@plt>		;call strdup
	 
	10.) EPILOG ;close it out like a bo$$
	 8048543:       c9                      leave  							;epilog
	 8048544:       c3                      ret								;return
<-------------------------------------------------------------------------------------------------------------------------------------------------------------------->
*going to try a ret2libc, probably going to have to use a gadget. If we use the built in ret we can use the ret to ret to itself once, which should get
* past the issue of the return check. From there we can supply a second address into libc and use the system() exploit from stack6.
